<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrap Calculator Tests</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        .test-result { margin: 10px 0; padding: 5px; border-radius: 3px; }
        .pass { background-color: #d4edda; color: #155724; }
        .fail { background-color: #f8d7da; color: #721c24; }
        .test-suite { margin: 20px 0; border: 1px solid #ccc; padding: 15px; }
        .test-suite h3 { margin-top: 0; }
    </style>
</head>
<body>
    <h1>Scrap Calculator Tests</h1>
    <div id="test-results"></div>

    <!-- Include required classes -->
    <script src="src/js/services/CalculationService.js"></script>
    <script src="src/js/storage.js"></script>
    <script src="src/js/services/DataManager.js"></script>
    <script src="src/js/services/StreakCalculator.js"></script>
    <script src="src/js/services/StreakDisplayComponents.js"></script>

    <script>
        // Simple test framework
        class TestRunner {
            constructor() {
                this.results = [];
                this.currentSuite = null;
            }

            describe(name, fn) {
                this.currentSuite = name;
                console.log(`\n--- ${name} ---`);
                fn();
                this.renderResults();
            }

            test(name, fn) {
                try {
                    fn();
                    this.results.push({
                        suite: this.currentSuite,
                        name: name,
                        status: 'pass',
                        error: null
                    });
                    console.log(`✓ ${name}`);
                } catch (error) {
                    this.results.push({
                        suite: this.currentSuite,
                        name: name,
                        status: 'fail',
                        error: error.message
                    });
                    console.log(`✗ ${name}: ${error.message}`);
                }
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${expected}, but got ${actual}`);
                        }
                    },
                    toEqual: (expected) => {
                        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                    },
                    toBeTruthy: () => {
                        if (!actual) {
                            throw new Error(`Expected truthy value, but got ${actual}`);
                        }
                    },
                    toBeFalsy: () => {
                        if (actual) {
                            throw new Error(`Expected falsy value, but got ${actual}`);
                        }
                    },
                    toBeGreaterThan: (expected) => {
                        if (actual <= expected) {
                            throw new Error(`Expected ${actual} to be greater than ${expected}`);
                        }
                    },
                    toHaveLength: (expected) => {
                        if (actual.length !== expected) {
                            throw new Error(`Expected length ${expected}, but got ${actual.length}`);
                        }
                    },
                    toBeLessThan: (expected) => {
                        if (actual >= expected) {
                            throw new Error(`Expected ${actual} to be less than ${expected}`);
                        }
                    }
                };
            }

            renderResults() {
                const container = document.getElementById('test-results');
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                suiteDiv.innerHTML = `<h3>${this.currentSuite}</h3>`;

                const suiteResults = this.results.filter(r => r.suite === this.currentSuite);
                suiteResults.forEach(result => {
                    const div = document.createElement('div');
                    div.className = `test-result ${result.status}`;
                    div.innerHTML = `${result.status === 'pass' ? '✓' : '✗'} ${result.name}`;
                    if (result.error) {
                        div.innerHTML += `<br><small>${result.error}</small>`;
                    }
                    suiteDiv.appendChild(div);
                });

                container.appendChild(suiteDiv);
            }
        }

        const runner = new TestRunner();

        // Mock IndexedDB for testing
        class MockStorageManager {
            constructor() {
                this.data = {};
                this.weeklyHistory = [];
            }

            async initialize() {
                return Promise.resolve();
            }

            async saveCurrentProgress(data) {
                this.data.currentProgress = data;
                return Promise.resolve();
            }

            async loadCurrentProgress() {
                return Promise.resolve(this.data.currentProgress);
            }

            async saveWeeklyHistory(weeklyHistory) {
                this.weeklyHistory = weeklyHistory;
                return Promise.resolve();
            }

            async loadWeeklyHistory() {
                return Promise.resolve(this.weeklyHistory);
            }

            async clearAllData() {
                this.data = {};
                this.weeklyHistory = [];
                return Promise.resolve();
            }

            async exportData() {
                return Promise.resolve({
                    currentProgress: this.data.currentProgress || {},
                    weeklyHistory: this.weeklyHistory
                });
            }

            async importData(data) {
                if (data.currentProgress) {
                    this.data.currentProgress = data.currentProgress;
                }
                if (data.weeklyHistory) {
                    this.weeklyHistory = data.weeklyHistory;
                }
                return Promise.resolve();
            }

            async saveSetting(key, value) {
                if (!this.data.settings) this.data.settings = {};
                this.data.settings[key] = value;
                return Promise.resolve();
            }

            async loadSetting(key) {
                return Promise.resolve(this.data.settings?.[key]);
            }
        }

        // StreakCalculator Tests  
        runner.describe('StreakCalculator - Core Functionality', () => {
            runner.test('should return empty streaks for empty data', () => {
                const calculator = new StreakCalculator();
                const result = calculator.calculateStreaks([]);
                
                runner.expect(result.currentStreak).toBe(0);
                runner.expect(result.longestStreak).toBe(0);
                runner.expect(result.streakHistory).toHaveLength(0);
            });

            runner.test('should calculate streak of 1 for single achievement', () => {
                const calculator = new StreakCalculator();
                const dailyData = [
                    {
                        date: '2025-07-23',
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    }
                ];
                
                const result = calculator.calculateStreaks(dailyData);
                
                runner.expect(result.currentStreak).toBe(1);
                runner.expect(result.longestStreak).toBe(1);
                runner.expect(result.streakHistory).toHaveLength(0); // No ended streaks yet
            });

            runner.test('should calculate consecutive achievements correctly', () => {
                const calculator = new StreakCalculator();
                const dailyData = [
                    {
                        date: '2025-07-21',
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-22',
                        merges: 7500,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-23',
                        merges: 9000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    }
                ];
                
                const result = calculator.calculateStreaks(dailyData);
                
                runner.expect(result.currentStreak).toBe(3);
                runner.expect(result.longestStreak).toBe(3);
            });

            runner.test('should reset current streak when target missed', () => {
                const calculator = new StreakCalculator();
                const dailyData = [
                    {
                        date: '2025-07-20',
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-21',
                        merges: 8500,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-22',
                        merges: 5000,
                        dailyTarget: 7143,
                        achievedTarget: false
                    },
                    {
                        date: '2025-07-23',
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    }
                ];
                
                const result = calculator.calculateStreaks(dailyData);
                
                runner.expect(result.currentStreak).toBe(1); // Only last day
                runner.expect(result.longestStreak).toBe(2); // Previous 2-day streak
                runner.expect(result.streakHistory).toHaveLength(1);
                runner.expect(result.streakHistory[0].length).toBe(2);
            });

            runner.test('should handle non-consecutive dates properly', () => {
                const calculator = new StreakCalculator();
                const dailyData = [
                    {
                        date: '2025-07-20',
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-22', // Skipped 7/21
                        merges: 8500,
                        dailyTarget: 7143,
                        achievedTarget: true
                    },
                    {
                        date: '2025-07-23',
                        merges: 9000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    }
                ];
                
                const result = calculator.calculateStreaks(dailyData);
                
                runner.expect(result.currentStreak).toBe(2); // 7/22 and 7/23
                runner.expect(result.longestStreak).toBe(2);
                runner.expect(result.streakHistory).toHaveLength(1);
                runner.expect(result.streakHistory[0].length).toBe(1); // Single day streak on 7/20
            });

            runner.test('should track multiple streaks in history', () => {
                const calculator = new StreakCalculator();
                const dailyData = [
                    // First streak
                    { date: '2025-07-15', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    { date: '2025-07-16', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    { date: '2025-07-17', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    // Break
                    { date: '2025-07-18', merges: 5000, dailyTarget: 7143, achievedTarget: false },
                    // Second streak
                    { date: '2025-07-19', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    { date: '2025-07-20', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    // Break
                    { date: '2025-07-21', merges: 4000, dailyTarget: 7143, achievedTarget: false },
                    // Current streak
                    { date: '2025-07-22', merges: 8000, dailyTarget: 7143, achievedTarget: true },
                    { date: '2025-07-23', merges: 9000, dailyTarget: 7143, achievedTarget: true }
                ];
                
                const result = calculator.calculateStreaks(dailyData);
                
                runner.expect(result.currentStreak).toBe(2);
                runner.expect(result.longestStreak).toBe(3);
                runner.expect(result.streakHistory).toHaveLength(2);
            });
        });

        runner.describe('StreakCalculator - Daily Target Calculation', () => {
            runner.test('should calculate daily target as weekly goal divided by 7', () => {
                const calculator = new StreakCalculator();
                
                runner.expect(calculator.calculateDailyTarget(50000)).toBe(7143); // 50000/7 rounded up
                runner.expect(calculator.calculateDailyTarget(35000)).toBe(5000); // 35000/7 rounded up
                runner.expect(calculator.calculateDailyTarget(70000)).toBe(10000); // 70000/7 = 10000 exactly
            });

            runner.test('should determine if daily target is achieved', () => {
                const calculator = new StreakCalculator();
                
                runner.expect(calculator.isDailyTargetAchieved(8000, 7143)).toBeTruthy();
                runner.expect(calculator.isDailyTargetAchieved(7143, 7143)).toBeTruthy(); // Exactly equal
                runner.expect(calculator.isDailyTargetAchieved(7000, 7143)).toBeFalsy();
                runner.expect(calculator.isDailyTargetAchieved(0, 7143)).toBeFalsy();
            });

            runner.test('should handle edge cases for target calculations', () => {
                const calculator = new StreakCalculator();
                
                runner.expect(calculator.calculateDailyTarget(0)).toBe(0);
                runner.expect(calculator.calculateDailyTarget(1)).toBe(1); // 1/7 rounded up
                runner.expect(calculator.isDailyTargetAchieved(100, 0)).toBeTruthy(); // Zero target
                runner.expect(calculator.isDailyTargetAchieved(0, 0)).toBeTruthy(); // Both zero
            });
        });

        runner.describe('StreakCalculator - 5PM Boundary Logic', () => {
            runner.test('should correctly identify consecutive days across 5pm boundaries', () => {
                const calculator = new StreakCalculator();
                
                // Mock dates that cross 5pm boundaries (Sunday to Monday)
                const sunday5pm = new Date('2025-07-20T17:00:00.000Z');
                const monday5pm = new Date('2025-07-21T17:00:00.000Z');
                
                runner.expect(calculator.isConsecutiveDay(sunday5pm, monday5pm)).toBeTruthy();
            });

            runner.test('should identify non-consecutive days properly', () => {
                const calculator = new StreakCalculator();
                
                const sunday5pm = new Date('2025-07-20T17:00:00.000Z');
                const tuesday5pm = new Date('2025-07-22T17:00:00.000Z'); // Skipped Monday
                
                runner.expect(calculator.isConsecutiveDay(sunday5pm, tuesday5pm)).toBeFalsy();
            });

            runner.test('should handle same day as non-consecutive', () => {
                const calculator = new StreakCalculator();
                
                const sunday5pm = new Date('2025-07-20T17:00:00.000Z');
                const sundayLate = new Date('2025-07-20T22:00:00.000Z'); // Same day, later time
                
                runner.expect(calculator.isConsecutiveDay(sunday5pm, sundayLate)).toBeFalsy();
            });

            runner.test('should handle timezone consistency', () => {
                const calculator = new StreakCalculator();
                
                // Dates in same timezone, 24 hours apart
                const day1 = new Date('2025-07-20T17:00:00.000Z');
                const day2 = new Date('2025-07-21T17:00:00.000Z');
                const day3 = new Date('2025-07-22T17:00:00.000Z');
                
                runner.expect(calculator.isConsecutiveDay(day1, day2)).toBeTruthy();
                runner.expect(calculator.isConsecutiveDay(day2, day3)).toBeTruthy();
                runner.expect(calculator.isConsecutiveDay(day1, day3)).toBeFalsy(); // 48 hours apart
            });
        });

        // Weekly Chart Tooltip Tests
        runner.describe('Weekly Chart Tooltip Formatting', () => {
            runner.test('should format tooltip with week date range', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 30000;
                dataManager.state.targetGoal = 50000;
                
                const tooltipData = dataManager.getWeeklyTooltipData('2025-07-20');
                
                runner.expect(tooltipData.dateRange).toBe('Jul 20 - Jul 27');
                runner.expect(tooltipData.merges).toBe('30,000');
                runner.expect(tooltipData.target).toBe('50,000');
                runner.expect(tooltipData.status).toBe('60% of target');
            });

            runner.test('should handle completed weeks in tooltip', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                const weekData = {
                    weekId: '2025-07-13',
                    weekStart: '2025-07-13T17:00:00.000Z',
                    weekEnd: '2025-07-20T17:00:00.000Z',
                    finalMerges: 52000,
                    targetGoal: 50000,
                    completed: true
                };
                
                const tooltipData = dataManager.getWeeklyTooltipData('2025-07-13', weekData);
                
                runner.expect(tooltipData.status).toBe('104% of target (✓ Goal reached!)');
                runner.expect(tooltipData.merges).toBe('52,000');
            });

            runner.test('should distinguish current week in tooltip', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 25000;
                
                const tooltipData = dataManager.getWeeklyTooltipData('2025-07-20');
                
                runner.expect(tooltipData.weekType).toBe('Current Week');
                runner.expect(tooltipData.dateRange).toBe('Jul 20 - Jul 27');
            });
        });

        // Weekly Chart Data Aggregation Tests
        runner.describe('Weekly Chart Data Aggregation', () => {
            runner.test('should combine weeklyHistory with current week data', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                // Mock historical weeks
                dataManager.state.weeklyHistory = [
                    {
                        weekId: '2025-07-06',
                        weekStart: '2025-07-06T17:00:00.000Z',
                        weekEnd: '2025-07-13T17:00:00.000Z',
                        finalMerges: 48000,
                        targetGoal: 50000,
                        completed: false,
                        achievementRate: 96
                    },
                    {
                        weekId: '2025-07-13',
                        weekStart: '2025-07-13T17:00:00.000Z',
                        weekEnd: '2025-07-20T17:00:00.000Z',
                        finalMerges: 52000,
                        targetGoal: 50000,
                        completed: true,
                        achievementRate: 104
                    }
                ];
                
                // Current week
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 25000;
                dataManager.state.targetGoal = 50000;
                
                // Get combined weekly data
                const combinedWeeklyData = dataManager.getCombinedWeeklyData();
                
                runner.expect(combinedWeeklyData).toHaveLength(3);
                runner.expect(combinedWeeklyData[2].weekId).toBe('2025-07-20');
                runner.expect(combinedWeeklyData[2].finalMerges).toBe(25000);
                runner.expect(combinedWeeklyData[2].isCurrentWeek).toBeTruthy();
            });

            runner.test('should handle empty weeklyHistory gracefully', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                // No historical weeks
                dataManager.state.weeklyHistory = [];
                
                // Current week only
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 15000;
                dataManager.state.targetGoal = 50000;
                
                // Get combined weekly data
                const combinedWeeklyData = dataManager.getCombinedWeeklyData();
                
                runner.expect(combinedWeeklyData).toHaveLength(1);
                runner.expect(combinedWeeklyData[0].weekId).toBe('2025-07-20');
                runner.expect(combinedWeeklyData[0].finalMerges).toBe(15000);
                runner.expect(combinedWeeklyData[0].isCurrentWeek).toBeTruthy();
            });

            runner.test('should properly order weeks chronologically', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                // Historical weeks in random order
                dataManager.state.weeklyHistory = [
                    {
                        weekId: '2025-07-13',
                        weekStart: '2025-07-13T17:00:00.000Z',
                        finalMerges: 52000
                    },
                    {
                        weekId: '2025-07-06',
                        weekStart: '2025-07-06T17:00:00.000Z',
                        finalMerges: 48000
                    }
                ];
                
                // Current week
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 25000;
                
                const combinedWeeklyData = dataManager.getCombinedWeeklyData();
                
                // Should be ordered chronologically
                runner.expect(combinedWeeklyData[0].weekId).toBe('2025-07-06');
                runner.expect(combinedWeeklyData[1].weekId).toBe('2025-07-13');
                runner.expect(combinedWeeklyData[2].weekId).toBe('2025-07-20');
            });

            runner.test('should include proper chart tooltip data', () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                
                dataManager.state.weekStartDate = new Date('2025-07-20T17:00:00.000Z');
                dataManager.state.weekEndDate = new Date('2025-07-27T17:00:00.000Z');
                dataManager.state.currentMerges = 30000;
                dataManager.state.targetGoal = 50000;
                
                const combinedWeeklyData = dataManager.getCombinedWeeklyData();
                const currentWeek = combinedWeeklyData[0];
                
                runner.expect(currentWeek.weekStart).toBe('2025-07-20T17:00:00.000Z');
                runner.expect(currentWeek.weekEnd).toBe('2025-07-27T17:00:00.000Z');
                runner.expect(currentWeek.targetGoal).toBe(50000);
                runner.expect(currentWeek.achievementRate).toBe(60);
            });
        });

        // Weekly Data Archiving Tests
        runner.describe('Weekly Data Archiving', () => {
            runner.test('should detect when current week has ended', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Set up a week that has already ended
                const pastWeekEnd = new Date();
                pastWeekEnd.setDate(pastWeekEnd.getDate() - 1); // Yesterday
                pastWeekEnd.setHours(17, 0, 0, 0);
                
                dataManager.state.weekEndDate = pastWeekEnd;
                
                const hasEnded = dataManager.checkWeekTransition();
                runner.expect(hasEnded).toBeTruthy();
            });

            runner.test('should not detect transition when week is still active', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Set up a week that hasn't ended yet
                const futureWeekEnd = new Date();
                futureWeekEnd.setDate(futureWeekEnd.getDate() + 2); // Day after tomorrow
                futureWeekEnd.setHours(17, 0, 0, 0);
                
                dataManager.state.weekEndDate = futureWeekEnd;
                
                const hasEnded = dataManager.checkWeekTransition();
                runner.expect(hasEnded).toBeFalsy();
            });

            runner.test('should archive completed week data to history', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Set up test data for a completed week
                const weekStart = new Date('2025-07-20T17:00:00.000Z'); // Previous Sunday 5pm
                const weekEnd = new Date('2025-07-27T17:00:00.000Z');   // Next Sunday 5pm
                
                dataManager.state.weekStartDate = weekStart;
                dataManager.state.weekEndDate = weekEnd;
                dataManager.state.currentMerges = 45000;
                dataManager.state.targetGoal = 50000;
                dataManager.state.mergeRatePer10Min = 125;

                // Archive the week
                const archivedWeek = await dataManager.saveCurrentWeekToHistory();

                // Verify the archived data structure
                runner.expect(archivedWeek.weekId).toBe('2025-07-20');
                runner.expect(archivedWeek.finalMerges).toBe(45000);
                runner.expect(archivedWeek.targetGoal).toBe(50000);
                runner.expect(archivedWeek.completed).toBeFalsy();
                runner.expect(archivedWeek.achievementRate).toBe(90);
            });

            runner.test('should mark week as completed when goal is reached', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Set up test data for a completed week with goal reached
                const weekStart = new Date('2025-07-20T17:00:00.000Z');
                const weekEnd = new Date('2025-07-27T17:00:00.000Z');
                
                dataManager.state.weekStartDate = weekStart;
                dataManager.state.weekEndDate = weekEnd;
                dataManager.state.currentMerges = 52000; // Exceeded goal
                dataManager.state.targetGoal = 50000;

                // Archive the week
                const archivedWeek = await dataManager.saveCurrentWeekToHistory();

                // Verify it's marked as completed
                runner.expect(archivedWeek.completed).toBeTruthy();
                runner.expect(archivedWeek.achievementRate).toBe(104);
            });

            runner.test('should reset current progress after week transition', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Set up initial state
                dataManager.state.currentMerges = 45000;
                dataManager.state.mergeRatePer10Min = 125;
                dataManager.state.targetGoal = 50000;

                // Mock a week that has ended
                const pastWeekEnd = new Date();
                pastWeekEnd.setDate(pastWeekEnd.getDate() - 1);
                pastWeekEnd.setHours(17, 0, 0, 0);
                dataManager.state.weekEndDate = pastWeekEnd;

                // Handle the transition
                await dataManager.handleWeekTransition();

                // Verify current merges were reset
                runner.expect(dataManager.state.currentMerges).toBe(0);
                
                // Verify settings were preserved
                runner.expect(dataManager.state.mergeRatePer10Min).toBe(125);
                runner.expect(dataManager.state.targetGoal).toBe(50000);
            });

            runner.test('should update week bounds after transition', async () => {
                const mockStorage = new MockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                const originalWeekStart = dataManager.state.weekStartDate;
                const originalWeekEnd = dataManager.state.weekEndDate;

                // Mock a week that has ended
                const pastWeekEnd = new Date();
                pastWeekEnd.setDate(pastWeekEnd.getDate() - 1);
                pastWeekEnd.setHours(17, 0, 0, 0);
                dataManager.state.weekEndDate = pastWeekEnd;

                // Handle the transition
                await dataManager.handleWeekTransition();

                // Verify week bounds were updated
                const newWeekStart = dataManager.state.weekStartDate;
                const newWeekEnd = dataManager.state.weekEndDate;

                // New week should be 7 days later
                runner.expect(newWeekStart.getTime()).toBeGreaterThan(originalWeekStart.getTime());
                runner.expect(newWeekEnd.getTime()).toBeGreaterThan(originalWeekEnd.getTime());
            });
        });

        // Database Migration and Streak Data Storage Tests
        runner.describe('Database Migration - Schema Version 3', () => {
            runner.test('should initialize streakSummary object store on database upgrade', async () => {
                // Mock IndexedDB database upgrade scenario
                const mockUpgradeEvent = {
                    oldVersion: 2,
                    target: {
                        result: {
                            objectStoreNames: ['currentProgress', 'settings', 'weeklyHistory'],
                            createObjectStore: function(name, options) {
                                this.objectStoreNames.push(name);
                                return {
                                    name: name,
                                    keyPath: options.keyPath,
                                    createIndex: function() {}
                                };
                            }
                        }
                    }
                };

                // Simulate upgrade handler logic
                const db = mockUpgradeEvent.target.result;
                if (mockUpgradeEvent.oldVersion < 3) {
                    const streakStore = db.createObjectStore('streakSummary', { keyPath: 'id' });
                }

                // Verify new object store was created
                runner.expect(db.objectStoreNames.includes('streakSummary')).toBeTruthy();
                runner.expect(db.objectStoreNames).toHaveLength(4);
            });

            runner.test('should maintain backwards compatibility with existing dailyProgress objects', async () => {
                const mockStorage = new MockStorageManager();
                await mockStorage.initialize();

                // Test legacy daily progress object without streak fields
                const legacyDailyData = {
                    id: '2025-07-23',
                    date: '2025-07-23', 
                    merges: 7500,
                    goalTarget: 50000,
                    lastUpdated: Date.now()
                };

                // Should be able to save and load legacy format
                mockStorage.data.dailyProgress = { '2025-07-23': legacyDailyData };
                const loaded = mockStorage.data.dailyProgress['2025-07-23'];

                runner.expect(loaded.merges).toBe(7500);
                runner.expect(loaded.goalTarget).toBe(50000);
                // New fields should be undefined but not break functionality
                runner.expect(loaded.dailyTarget).toBe(undefined);
                runner.expect(loaded.achievedTarget).toBe(undefined);
            });

            runner.test('should calculate initial streak data from existing daily progress records', async () => {
                const mockStorage = new MockStorageManager();
                await mockStorage.initialize();

                // Mock existing daily progress data (3 consecutive achieving days)
                const existingDailyData = {
                    '2025-07-21': { date: '2025-07-21', merges: 8000, goalTarget: 50000 },
                    '2025-07-22': { date: '2025-07-22', merges: 7500, goalTarget: 50000 },
                    '2025-07-23': { date: '2025-07-23', merges: 9000, goalTarget: 50000 }
                };

                mockStorage.data.dailyProgress = existingDailyData;

                // Calculate initial streak summary from existing data
                const calculator = new StreakCalculator();
                const dailyArray = Object.values(existingDailyData).map(day => ({
                    ...day,
                    dailyTarget: Math.ceil(day.goalTarget / 7),
                    achievedTarget: day.merges >= Math.ceil(day.goalTarget / 7)
                }));

                const initialStreakSummary = calculator.calculateStreaks(dailyArray);

                runner.expect(initialStreakSummary.currentStreak).toBe(3);
                runner.expect(initialStreakSummary.longestStreak).toBe(3);
                runner.expect(initialStreakSummary.totalDaysAchieved).toBe(3);
            });
        });

        runner.describe('Streak Data Storage', () => {
            // Enhanced MockStorageManager for streak testing
            class StreakMockStorageManager extends MockStorageManager {
                constructor() {
                    super();
                    this.data.streakSummary = null;
                    this.data.dailyProgress = {};
                }

                async saveStreakSummary(streakData) {
                    this.data.streakSummary = { id: 'current', ...streakData };
                    return Promise.resolve();
                }

                async loadStreakSummary() {
                    return Promise.resolve(this.data.streakSummary);
                }

                async saveDailyProgress(dateStr, dailyData) {
                    this.data.dailyProgress[dateStr] = dailyData;
                    return Promise.resolve();
                }

                async loadAllDailyProgress() {
                    return Promise.resolve(Object.values(this.data.dailyProgress));
                }

                async updateDailyProgressWithStreak(dateStr, merges, goalTarget) {
                    // Calculate daily target and achievement
                    const dailyTarget = Math.ceil(goalTarget / 7);
                    const achievedTarget = merges >= dailyTarget;

                    // Create enhanced daily progress object
                    const dailyData = {
                        id: dateStr,
                        date: dateStr,
                        merges,
                        goalTarget,
                        dailyTarget,
                        achievedTarget,
                        lastUpdated: Date.now()
                    };

                    // Save daily progress
                    await this.saveDailyProgress(dateStr, dailyData);

                    // Recalculate streaks from all daily data
                    const allDailyProgress = await this.loadAllDailyProgress();
                    const calculator = new StreakCalculator();
                    const newStreakSummary = calculator.calculateStreaks(allDailyProgress);

                    // Save updated streak summary
                    await this.saveStreakSummary({
                        ...newStreakSummary,
                        lastCalculated: Date.now()
                    });

                    return dailyData;
                }
            }

            runner.test('should save and retrieve streak summary correctly', async () => {
                const mockStorage = new StreakMockStorageManager();
                await mockStorage.initialize();

                const testStreakSummary = {
                    currentStreak: 5,
                    longestStreak: 12,
                    totalDaysAchieved: 45,
                    lastCalculated: Date.now(),
                    streakHistory: [
                        { startDate: '2025-07-18', endDate: '2025-07-22', length: 5 }
                    ]
                };

                // Save streak summary
                await mockStorage.saveStreakSummary(testStreakSummary);

                // Load and verify
                const loaded = await mockStorage.loadStreakSummary();
                runner.expect(loaded.id).toBe('current');
                runner.expect(loaded.currentStreak).toBe(5);
                runner.expect(loaded.longestStreak).toBe(12);
                runner.expect(loaded.totalDaysAchieved).toBe(45);
                runner.expect(loaded.streakHistory).toHaveLength(1);
            });

            runner.test('should store extended daily progress with streak fields', async () => {
                const mockStorage = new StreakMockStorageManager();
                await mockStorage.initialize();

                const testDailyData = {
                    id: '2025-07-23',
                    date: '2025-07-23',
                    merges: 8000,
                    goalTarget: 50000,
                    dailyTarget: 7143,
                    achievedTarget: true,
                    streakDay: 3,
                    lastUpdated: Date.now()
                };

                await mockStorage.saveDailyProgress('2025-07-23', testDailyData);

                const allProgress = await mockStorage.loadAllDailyProgress();
                const savedData = allProgress[0];

                runner.expect(savedData.dailyTarget).toBe(7143);
                runner.expect(savedData.achievedTarget).toBeTruthy();
                runner.expect(savedData.streakDay).toBe(3);
            });

            runner.test('should perform atomic updates of daily progress and streak summary', async () => {
                const mockStorage = new StreakMockStorageManager();
                await mockStorage.initialize();

                // Seed with some existing data
                await mockStorage.updateDailyProgressWithStreak('2025-07-21', 8000, 50000);
                await mockStorage.updateDailyProgressWithStreak('2025-07-22', 7500, 50000);

                // Add new day that should extend streak
                const result = await mockStorage.updateDailyProgressWithStreak('2025-07-23', 9000, 50000);

                // Verify daily progress was saved correctly
                runner.expect(result.merges).toBe(9000);
                runner.expect(result.dailyTarget).toBe(7143);
                runner.expect(result.achievedTarget).toBeTruthy();

                // Verify streak summary was updated
                const streakSummary = await mockStorage.loadStreakSummary();
                runner.expect(streakSummary.currentStreak).toBe(3);
                runner.expect(streakSummary.longestStreak).toBe(3);
                runner.expect(streakSummary.totalDaysAchieved).toBe(3);
            });

            runner.test('should handle corrupted streak data gracefully', async () => {
                const mockStorage = new StreakMockStorageManager();
                await mockStorage.initialize();

                // Simulate corrupted streak summary (missing required fields)
                mockStorage.data.streakSummary = { id: 'current', corrupted: true };

                // Should return null or default values instead of throwing
                const streakSummary = await mockStorage.loadStreakSummary();
                runner.expect(streakSummary.corrupted).toBeTruthy();

                // System should be able to recover by recalculating from daily data
                await mockStorage.updateDailyProgressWithStreak('2025-07-23', 8000, 50000);
                const recoveredSummary = await mockStorage.loadStreakSummary();
                
                runner.expect(recoveredSummary.currentStreak).toBe(1);
                runner.expect(recoveredSummary.corrupted).toBe(undefined);
            });

            runner.test('should limit streak history to prevent unbounded memory growth', async () => {
                const mockStorage = new StreakMockStorageManager();
                await mockStorage.initialize();

                // Create a long streak history (simulate 60 weeks of data)
                const calculator = new StreakCalculator();
                const longHistory = [];
                
                for (let i = 0; i < 60; i++) {
                    longHistory.push({
                        startDate: `2024-01-${String(i + 1).padStart(2, '0')}`,
                        endDate: `2024-01-${String(i + 1).padStart(2, '0')}`,
                        length: 1
                    });
                }

                const testStreakData = {
                    currentStreak: 0,
                    longestStreak: 1,
                    totalDaysAchieved: 60,
                    streakHistory: longHistory
                };

                await mockStorage.saveStreakSummary(testStreakData);
                const loaded = await mockStorage.loadStreakSummary();

                // History should be limited (typically to 52 weeks)
                runner.expect(loaded.streakHistory.length).toBeGreaterThan(0);
                // This is more about ensuring the system can handle large datasets
                // The actual limiting logic would be in the production code
            });
        });

        // Streak Display UI Component Tests
        runner.describe('Streak Display Components', () => {
            // Mock DOM elements for testing
            function createMockDOMElement(tagName, id, className) {
                const element = {
                    tagName: tagName.toUpperCase(),
                    id: id || '',
                    className: className || '',
                    innerHTML: '',
                    textContent: '',
                    style: {},
                    children: [],
                    appendChild: function(child) {
                        this.children.push(child);
                        return child;
                    },
                    querySelector: function(selector) {
                        return this.children.find(child => 
                            selector.includes('#') ? child.id === selector.slice(1) :
                            selector.includes('.') ? child.className === selector.slice(1) :
                            child.tagName === selector.toUpperCase()
                        );
                    },
                    addEventListener: function() {}
                };
                return element;
            }

            // Mock StreakDisplayComponents class
            class MockStreakDisplayComponents {
                constructor() {
                    this.currentStreakBadge = null;
                    this.streakMetricsCard = null;
                    this.achievementIndicators = [];
                }

                createCurrentStreakBadge(parentElement, streakCount) {
                    const badge = createMockDOMElement('div', 'current-streak-badge', 'streak-badge');
                    badge.innerHTML = `
                        <div class="streak-icon">🔥</div>
                        <div class="streak-count">${streakCount}</div>
                        <div class="streak-label">Day Streak</div>
                    `;
                    
                    if (parentElement && parentElement.appendChild) {
                        parentElement.appendChild(badge);
                    }
                    
                    this.currentStreakBadge = badge;
                    return badge;
                }

                createStreakMetricsCard(parentElement, streakData) {
                    const card = createMockDOMElement('div', 'streak-metrics-card', 'metrics-card');
                    card.innerHTML = `
                        <h3>Streak Analytics</h3>
                        <div class="streak-stats">
                            <div class="stat-item">
                                <span class="stat-label">Current Streak</span>
                                <span class="stat-value">${streakData.currentStreak} days</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Longest Streak</span>
                                <span class="stat-value">${streakData.longestStreak} days</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total Achieved</span>
                                <span class="stat-value">${streakData.totalDaysAchieved} days</span>
                            </div>
                        </div>
                    `;
                    
                    if (parentElement && parentElement.appendChild) {
                        parentElement.appendChild(card);
                    }
                    
                    this.streakMetricsCard = card;
                    return card;
                }

                addAchievementIndicators(chartData, streakData) {
                    const indicators = [];
                    
                    // Mock achievement indicators for chart data points
                    chartData.forEach((dataPoint, index) => {
                        const achieved = dataPoint.merges >= (dataPoint.goalTarget / 7);
                        if (achieved) {
                            const indicator = {
                                index: index,
                                date: dataPoint.date,
                                achieved: true,
                                cssClass: 'achievement-indicator',
                                icon: '✓'
                            };
                            indicators.push(indicator);
                        }
                    });
                    
                    this.achievementIndicators = indicators;
                    return indicators;
                }

                updateStreakBadge(streakCount) {
                    if (this.currentStreakBadge) {
                        this.currentStreakBadge.querySelector('.streak-count').textContent = streakCount;
                    }
                }

                updateStreakMetrics(streakData) {
                    if (this.streakMetricsCard) {
                        const stats = this.streakMetricsCard.querySelectorAll('.stat-value');
                        if (stats[0]) stats[0].textContent = `${streakData.currentStreak} days`;
                        if (stats[1]) stats[1].textContent = `${streakData.longestStreak} days`;
                        if (stats[2]) stats[2].textContent = `${streakData.totalDaysAchieved} days`;
                    }
                }
            }

            runner.test('should create current streak badge with proper structure', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'header-section');
                
                const badge = components.createCurrentStreakBadge(parentElement, 5);
                
                runner.expect(badge.id).toBe('current-streak-badge');
                runner.expect(badge.className).toBe('streak-badge');
                runner.expect(badge.innerHTML.includes('🔥')).toBeTruthy();
                runner.expect(badge.innerHTML.includes('5')).toBeTruthy();
                runner.expect(badge.innerHTML.includes('Day Streak')).toBeTruthy();
            });

            runner.test('should create streak metrics card with all statistics', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'analytics-section');
                const streakData = {
                    currentStreak: 7,
                    longestStreak: 14,
                    totalDaysAchieved: 45
                };
                
                const card = components.createStreakMetricsCard(parentElement, streakData);
                
                runner.expect(card.id).toBe('streak-metrics-card');
                runner.expect(card.className).toBe('metrics-card');
                runner.expect(card.innerHTML.includes('Streak Analytics')).toBeTruthy();
                runner.expect(card.innerHTML.includes('7 days')).toBeTruthy();
                runner.expect(card.innerHTML.includes('14 days')).toBeTruthy();
                runner.expect(card.innerHTML.includes('45 days')).toBeTruthy();
            });

            runner.test('should add achievement indicators to chart data', () => {
                const components = new MockStreakDisplayComponents();
                const chartData = [
                    { date: '2025-07-21', merges: 8000, goalTarget: 50000 },
                    { date: '2025-07-22', merges: 6000, goalTarget: 50000 },
                    { date: '2025-07-23', merges: 9000, goalTarget: 50000 }
                ];
                const streakData = { currentStreak: 2 };
                
                const indicators = components.addAchievementIndicators(chartData, streakData);
                
                // Should have indicators for days that achieved target (8000 >= 7143, 9000 >= 7143)
                runner.expect(indicators).toHaveLength(2);
                runner.expect(indicators[0].achieved).toBeTruthy();
                runner.expect(indicators[0].icon).toBe('✓');
                runner.expect(indicators[1].achieved).toBeTruthy();
            });

            runner.test('should update streak badge count dynamically', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'header-section');
                
                // Create initial badge
                components.createCurrentStreakBadge(parentElement, 3);
                
                // Mock querySelector for the test
                components.currentStreakBadge.querySelector = function(selector) {
                    if (selector === '.streak-count') {
                        return { textContent: '3' };
                    }
                    return null;
                };
                
                // Update the count
                components.updateStreakBadge(8);
                
                // Verify the mock update worked
                const countElement = components.currentStreakBadge.querySelector('.streak-count');
                runner.expect(countElement.textContent).toBe('8');
            });

            runner.test('should update streak metrics card with new data', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'analytics-section');
                
                const initialData = { currentStreak: 5, longestStreak: 10, totalDaysAchieved: 30 };
                components.createStreakMetricsCard(parentElement, initialData);
                
                // Mock querySelectorAll for the test
                components.streakMetricsCard.querySelectorAll = function(selector) {
                    if (selector === '.stat-value') {
                        return [
                            { textContent: '5 days' },
                            { textContent: '10 days' },
                            { textContent: '30 days' }
                        ];
                    }
                    return [];
                };
                
                const newData = { currentStreak: 8, longestStreak: 12, totalDaysAchieved: 38 };
                components.updateStreakMetrics(newData);
                
                // Verify the mock updates worked
                const statValues = components.streakMetricsCard.querySelectorAll('.stat-value');
                runner.expect(statValues[0].textContent).toBe('8 days');
                runner.expect(statValues[1].textContent).toBe('12 days');
                runner.expect(statValues[2].textContent).toBe('38 days');
            });

            runner.test('should handle zero streak counts gracefully', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'header-section');
                
                const badge = components.createCurrentStreakBadge(parentElement, 0);
                
                runner.expect(badge.innerHTML.includes('0')).toBeTruthy();
                runner.expect(badge.innerHTML.includes('Day Streak')).toBeTruthy();
            });

            runner.test('should handle empty streak data gracefully', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div', 'analytics-section');
                
                const emptyData = { currentStreak: 0, longestStreak: 0, totalDaysAchieved: 0 };
                const card = components.createStreakMetricsCard(parentElement, emptyData);
                
                runner.expect(card.innerHTML.includes('0 days')).toBeTruthy();
                runner.expect(card.className).toBe('metrics-card');
            });

            runner.test('should create proper CSS classes for styling', () => {
                const components = new MockStreakDisplayComponents();
                const parentElement = createMockDOMElement('div');
                
                const badge = components.createCurrentStreakBadge(parentElement, 5);
                const streakData = { currentStreak: 5, longestStreak: 10, totalDaysAchieved: 25 };
                const card = components.createStreakMetricsCard(parentElement, streakData);
                
                // Verify CSS classes for proper styling
                runner.expect(badge.className).toBe('streak-badge');
                runner.expect(card.className).toBe('metrics-card');
                runner.expect(badge.innerHTML.includes('streak-icon')).toBeTruthy();
                runner.expect(badge.innerHTML.includes('streak-count')).toBeTruthy();
                runner.expect(badge.innerHTML.includes('streak-label')).toBeTruthy();
            });
        });

        // Task 4.1: Integration Tests for Streak Tracking with DataManager
        runner.describe('DataManager - Streak Integration', () => {
            // Enhanced MockStorageManager that includes streak tracking methods
            class IntegratedMockStorageManager extends MockStorageManager {
                constructor() {
                    super();
                    this.data.streakSummary = null;
                    this.data.dailyProgress = {};
                }

                async saveStreakSummary(streakData) {
                    this.data.streakSummary = { id: 'current', ...streakData };
                    return Promise.resolve();
                }

                async loadStreakSummary() {
                    return Promise.resolve(this.data.streakSummary);
                }

                async saveDailyProgress(dateStr, dailyData) {
                    this.data.dailyProgress[dateStr] = dailyData;
                    return Promise.resolve();
                }

                async getAllDailyProgress() {
                    return Promise.resolve(Object.values(this.data.dailyProgress));
                }
            }

            runner.test('should trigger streak calculations when daily progress is updated', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Mock the StreakCalculator availability
                const originalStreakCalculator = window.StreakCalculator;
                window.StreakCalculator = class {
                    calculateStreaks(dailyData) {
                        const achievedDays = dailyData.filter(d => d.achievedTarget);
                        return {
                            currentStreak: achievedDays.length,
                            longestStreak: achievedDays.length,
                            totalDaysAchieved: achievedDays.length,
                            streakHistory: []
                        };
                    }
                };

                // Set up initial state
                dataManager.state.targetGoal = 50000;
                
                // Update daily progress which should trigger streak calculation
                await dataManager.updateDailyProgressWithStreak('2025-07-23', 8000, 50000);

                // Verify streak summary was created and saved
                const streakSummary = await mockStorage.loadStreakSummary();
                runner.expect(streakSummary).toBeTruthy();
                runner.expect(streakSummary.currentStreak).toBe(1);
                runner.expect(streakSummary.totalDaysAchieved).toBe(1);

                // Restore original StreakCalculator
                window.StreakCalculator = originalStreakCalculator;
            });

            runner.test('should update daily progress with enhanced achievement tracking fields', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Update daily progress
                const result = await dataManager.updateDailyProgressWithStreak('2025-07-23', 8500, 50000);

                // Verify enhanced fields were added
                runner.expect(result.dailyTarget).toBe(7143); // 50000 / 7 rounded up
                runner.expect(result.achievedTarget).toBeTruthy(); // 8500 >= 7143
                runner.expect(result.date).toBe('2025-07-23');
                runner.expect(result.merges).toBe(8500);
                runner.expect(result.goalTarget).toBe(50000);
            });

            runner.test('should mark daily progress as not achieved when below target', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Update with merge count below daily target
                const result = await dataManager.updateDailyProgressWithStreak('2025-07-23', 5000, 50000);

                // Verify achievement tracking
                runner.expect(result.dailyTarget).toBe(7143);
                runner.expect(result.achievedTarget).toBeFalsy(); // 5000 < 7143
                runner.expect(result.merges).toBe(5000);
            });

            runner.test('should handle streak calculation errors gracefully', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Mock StreakCalculator that throws an error
                const originalStreakCalculator = window.StreakCalculator;
                window.StreakCalculator = class {
                    calculateStreaks() {
                        throw new Error('Streak calculation failed');
                    }
                };

                // Update should still work even if streak calculation fails
                let result;
                try {
                    result = await dataManager.updateDailyProgressWithStreak('2025-07-23', 8000, 50000);
                } catch (error) {
                    // Should not throw - error should be handled internally
                    runner.expect(false).toBeTruthy(); // Force test failure if exception escapes
                }

                // Daily progress should still be saved
                runner.expect(result.merges).toBe(8000);
                runner.expect(result.achievedTarget).toBeTruthy();

                // Restore original StreakCalculator
                window.StreakCalculator = originalStreakCalculator;
            });

            runner.test('should convert nested dailyHistory to flat array for streak calculation', () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);

                // Set up nested dailyHistory structure (existing format)
                dataManager.state.dailyHistory = {
                    '2025-07-21': { date: '2025-07-21', merges: 8000, goalTarget: 50000 },
                    '2025-07-22': { date: '2025-07-22', merges: 7000, goalTarget: 50000 },
                    '2025-07-23': { date: '2025-07-23', merges: 9000, goalTarget: 50000 }
                };

                // Get flat array for streak calculation
                const flatArray = dataManager.getAllDailyProgressForStreaks();

                runner.expect(flatArray).toHaveLength(3);
                runner.expect(flatArray[0].date).toBe('2025-07-21');
                runner.expect(flatArray[0].dailyTarget).toBe(7143);
                runner.expect(flatArray[0].achievedTarget).toBeTruthy(); // 8000 >= 7143
                runner.expect(flatArray[1].achievedTarget).toBeFalsy(); // 7000 < 7143
                runner.expect(flatArray[2].achievedTarget).toBeTruthy(); // 9000 >= 7143
            });

            runner.test('should sort daily progress by date for consistent streak calculation', () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);

                // Set up dailyHistory with dates in random order
                dataManager.state.dailyHistory = {
                    '2025-07-23': { date: '2025-07-23', merges: 9000, goalTarget: 50000 },
                    '2025-07-21': { date: '2025-07-21', merges: 8000, goalTarget: 50000 },
                    '2025-07-22': { date: '2025-07-22', merges: 7500, goalTarget: 50000 }
                };

                const sortedArray = dataManager.getAllDailyProgressForStreaks();

                // Should be sorted by date ascending
                runner.expect(sortedArray[0].date).toBe('2025-07-21');
                runner.expect(sortedArray[1].date).toBe('2025-07-22');
                runner.expect(sortedArray[2].date).toBe('2025-07-23');
            });

            runner.test('should handle empty dailyHistory gracefully', () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);

                // Empty dailyHistory
                dataManager.state.dailyHistory = {};

                const flatArray = dataManager.getAllDailyProgressForStreaks();

                runner.expect(flatArray).toHaveLength(0);
                runner.expect(Array.isArray(flatArray)).toBeTruthy();
            });

            runner.test('should load existing streak summary from storage', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Pre-populate storage with streak summary
                const existingStreak = {
                    currentStreak: 5,
                    longestStreak: 12,
                    totalDaysAchieved: 45,
                    lastCalculated: Date.now()
                };
                await mockStorage.saveStreakSummary(existingStreak);

                // Load streak summary
                const loaded = await dataManager.getStreakSummary();

                runner.expect(loaded.currentStreak).toBe(5);
                runner.expect(loaded.longestStreak).toBe(12);
                runner.expect(loaded.totalDaysAchieved).toBe(45);
            });

            runner.test('should return null when no streak summary exists', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // No streak summary in storage
                const loaded = await dataManager.getStreakSummary();

                runner.expect(loaded).toBe(null);
            });

            runner.test('should preserve streak data through DataManager state reloads', async () => {
                const mockStorage = new IntegratedMockStorageManager();
                const dataManager = new DataManager(mockStorage);
                await dataManager.initialize();

                // Mock StreakCalculator
                const originalStreakCalculator = window.StreakCalculator;
                window.StreakCalculator = class {
                    calculateStreaks(dailyData) {
                        return {
                            currentStreak: dailyData.length,
                            longestStreak: dailyData.length,
                            totalDaysAchieved: dailyData.length,
                            streakHistory: []
                        };
                    }
                };

                // Add some daily progress
                await dataManager.updateDailyProgressWithStreak('2025-07-21', 8000, 50000);
                await dataManager.updateDailyProgressWithStreak('2025-07-22', 7500, 50000);

                // Simulate a reload by creating new DataManager instance
                const newDataManager = new DataManager(mockStorage);
                await newDataManager.initialize();

                // Streak data should still be accessible
                const streakSummary = await newDataManager.getStreakSummary();
                runner.expect(streakSummary.currentStreak).toBe(2);
                runner.expect(streakSummary.totalDaysAchieved).toBe(2);

                // Restore original StreakCalculator
                window.StreakCalculator = originalStreakCalculator;
            });
        });

        // Performance Tests for Large Datasets - Task 5.1
        runner.describe('Performance Tests - Large Dataset Handling', () => {
            // Helper function to generate large datasets
            function generateLargeDailyDataset(days, goalTarget = 50000) {
                const dataset = [];
                const startDate = new Date('2023-01-01');
                
                for (let i = 0; i < days; i++) {
                    const currentDate = new Date(startDate);
                    currentDate.setDate(startDate.getDate() + i);
                    
                    const dateStr = currentDate.toISOString().split('T')[0];
                    const dailyTarget = Math.ceil(goalTarget / 7);
                    
                    // Simulate realistic achievement pattern (70% success rate)
                    const achieved = Math.random() < 0.7;
                    const merges = achieved ? 
                        dailyTarget + Math.floor(Math.random() * 2000) : 
                        Math.floor(Math.random() * dailyTarget);
                    
                    dataset.push({
                        date: dateStr,
                        merges: merges,
                        dailyTarget: dailyTarget,
                        achievedTarget: achieved,
                        goalTarget: goalTarget
                    });
                }
                
                return dataset;
            }
            
            // Helper function to measure performance
            function measurePerformance(fn, description) {
                const startTime = performance.now();
                const result = fn();
                const endTime = performance.now();
                const executionTime = endTime - startTime;
                
                console.log(`${description}: ${executionTime.toFixed(2)}ms`);
                return { result, executionTime };
            }

            runner.test('should calculate streaks for 100 days in under 10ms', () => {
                const calculator = new StreakCalculator();
                const largeDataset = generateLargeDailyDataset(100);
                
                const { executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(largeDataset),
                    'Streak calculation for 100 days'
                );
                
                runner.expect(executionTime).toBeLessThan(10);
            });
            
            runner.test('should calculate streaks for 365 days in under 20ms', () => {
                const calculator = new StreakCalculator();
                const largeDataset = generateLargeDailyDataset(365);
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(largeDataset),
                    'Streak calculation for 365 days (1 year)'
                );
                
                runner.expect(executionTime).toBeLessThan(20);
                runner.expect(result.currentStreak).toBeGreaterThan(-1); // Valid result
                runner.expect(result.longestStreak).toBeGreaterThan(-1);
            });
            
            runner.test('should calculate streaks for 730 days in under 50ms', () => {
                const calculator = new StreakCalculator();
                const largeDataset = generateLargeDailyDataset(730);
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(largeDataset),
                    'Streak calculation for 730 days (2 years)'
                );
                
                runner.expect(executionTime).toBeLessThan(50);
                runner.expect(result.currentStreak).toBeGreaterThan(-1);
                runner.expect(result.longestStreak).toBeGreaterThan(0); // Should have some streaks
            });
            
            runner.test('should calculate streaks for 1095 days in under 100ms', () => {
                const calculator = new StreakCalculator();
                const largeDataset = generateLargeDailyDataset(1095);
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(largeDataset),
                    'Streak calculation for 1095 days (3 years)'
                );
                
                runner.expect(executionTime).toBeLessThan(100);
                runner.expect(result.streakHistory.length).toBeGreaterThan(0);
                runner.expect(Array.isArray(result.streakHistory)).toBeTruthy();
            });
            
            runner.test('should handle memory efficiently with large datasets', () => {
                const calculator = new StreakCalculator();
                
                // Test multiple iterations to detect memory leaks
                for (let i = 0; i < 10; i++) {
                    const dataset = generateLargeDailyDataset(365);
                    const result = calculator.calculateStreaks(dataset);
                    
                    // Verify result integrity across iterations
                    runner.expect(typeof result.currentStreak).toBe('number');
                    runner.expect(typeof result.longestStreak).toBe('number');
                    runner.expect(Array.isArray(result.streakHistory)).toBeTruthy();
                }
                
                // If we reach here without errors, memory handling is acceptable
                runner.expect(true).toBeTruthy();
            });
            
            runner.test('should perform consistently across multiple calculations', () => {
                const calculator = new StreakCalculator();
                const dataset = generateLargeDailyDataset(365);
                const executionTimes = [];
                
                // Run calculation 5 times to test consistency
                for (let i = 0; i < 5; i++) {
                    const { executionTime } = measurePerformance(
                        () => calculator.calculateStreaks(dataset),
                        `Consistency test iteration ${i + 1}`
                    );
                    executionTimes.push(executionTime);
                }
                
                // Calculate average and variance
                const average = executionTimes.reduce((a, b) => a + b, 0) / executionTimes.length;
                const variance = executionTimes.reduce((acc, time) => 
                    acc + Math.pow(time - average, 2), 0) / executionTimes.length;
                
                console.log(`Performance consistency - Average: ${average.toFixed(2)}ms, Variance: ${variance.toFixed(2)}`);
                
                // Performance should be consistent (variance < 50% of average)
                runner.expect(variance).toBeLessThan(average * 0.5);
            });
            
            runner.test('should optimize date comparison for large datasets', () => {
                const calculator = new StreakCalculator();
                
                // Generate dataset with many consecutive days
                const dataset = [];
                const startDate = new Date('2023-01-01');
                
                for (let i = 0; i < 365; i++) {
                    const currentDate = new Date(startDate);
                    currentDate.setDate(startDate.getDate() + i);
                    const dateStr = currentDate.toISOString().split('T')[0];
                    
                    dataset.push({
                        date: dateStr,
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    });
                }
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(dataset),
                    'Date comparison optimization test'
                );
                
                // Should create one long streak efficiently
                runner.expect(result.currentStreak).toBe(365);
                runner.expect(result.longestStreak).toBe(365);
                runner.expect(executionTime).toBeLessThan(30);
            });
            
            runner.test('should handle data with gaps efficiently', () => {
                const calculator = new StreakCalculator();
                
                // Generate dataset with many gaps (every 3rd day missing)
                const dataset = [];
                const startDate = new Date('2023-01-01');
                
                for (let i = 0; i < 365; i++) {
                    if (i % 3 !== 0) { // Skip every 3rd day
                        continue;
                    }
                    
                    const currentDate = new Date(startDate);
                    currentDate.setDate(startDate.getDate() + i);
                    const dateStr = currentDate.toISOString().split('T')[0];
                    
                    dataset.push({
                        date: dateStr,
                        merges: 8000,
                        dailyTarget: 7143,
                        achievedTarget: true
                    });
                }
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(dataset),
                    'Dataset with gaps performance test'
                );
                
                // Should handle gaps without excessive computation
                runner.expect(result.longestStreak).toBe(1); // No consecutive days
                runner.expect(executionTime).toBeLessThan(25);
                runner.expect(result.streakHistory.length).toBeGreaterThan(50);
            });
            
            runner.test('should maintain accuracy under performance pressure', () => {
                const calculator = new StreakCalculator();
                
                // Create a known pattern: 7 days on, 1 day off, repeated
                const dataset = [];
                const startDate = new Date('2023-01-01');
                
                for (let i = 0; i < 400; i++) {
                    const currentDate = new Date(startDate);
                    currentDate.setDate(startDate.getDate() + i);
                    const dateStr = currentDate.toISOString().split('T')[0];
                    
                    // Pattern: 7 days achieved, 1 day not achieved
                    const achieved = (i % 8) !== 7;
                    
                    dataset.push({
                        date: dateStr,
                        merges: achieved ? 8000 : 5000,
                        dailyTarget: 7143,
                        achievedTarget: achieved
                    });
                }
                
                const { result, executionTime } = measurePerformance(
                    () => calculator.calculateStreaks(dataset),
                    'Accuracy under performance pressure'
                );
                
                // Should maintain accuracy: max streak of 7, many 7-day streaks in history
                runner.expect(result.longestStreak).toBe(7);
                runner.expect(result.streakHistory.length).toBeGreaterThan(40);
                runner.expect(executionTime).toBeLessThan(30);
                
                // Verify all streaks in history are length 7
                const sevenDayStreaks = result.streakHistory.filter(s => s.length === 7);
                runner.expect(sevenDayStreaks.length).toBeGreaterThan(40);
            });
        });

        // Error Handling and Data Recovery Tests - Task 5.4
        runner.describe('Error Handling and Data Recovery', () => {
            runner.test('should handle corrupted data gracefully', () => {
                const calculator = new StreakCalculator();
                
                // Test with various corrupted data formats
                const corruptedInputs = [
                    null,
                    undefined,
                    "invalid string",
                    42,
                    { notAnArray: true },
                    [null, undefined, "invalid"],
                    [{ date: "invalid-date", achievedTarget: "not-boolean" }],
                    [{ missingFields: true }]
                ];
                
                corruptedInputs.forEach((input, index) => {
                    const result = calculator.safeCalculateStreaks(input);
                    
                    runner.expect(typeof result).toBe('object');
                    runner.expect(typeof result.currentStreak).toBe('number');
                    runner.expect(typeof result.longestStreak).toBe('number');
                    runner.expect(Array.isArray(result.streakHistory)).toBeTruthy();
                    runner.expect(typeof result.totalDaysAchieved).toBe('number');
                });
            });
            
            runner.test('should validate daily achievement data correctly', () => {
                const calculator = new StreakCalculator();
                
                // Valid data should pass validation
                const validData = [
                    { date: '2025-07-21', achievedTarget: true, merges: 8000, dailyTarget: 7143 },
                    { date: '2025-07-22', achievedTarget: false, merges: 5000, dailyTarget: 7143 }
                ];
                
                const validErrors = calculator.validateDailyAchievementData(validData);
                runner.expect(validErrors).toHaveLength(0);
                
                // Invalid data should return errors
                const invalidData = [
                    { date: 'invalid-date', achievedTarget: true },
                    { date: '2025-07-22', achievedTarget: 'not-boolean' },
                    { missingDate: true, achievedTarget: true },
                    { date: '2025-07-21', achievedTarget: true } // Duplicate date
                ];
                
                const invalidErrors = calculator.validateDailyAchievementData(invalidData);
                runner.expect(invalidErrors.length).toBeGreaterThan(0);
            });
            
            runner.test('should sanitize corrupted data', () => {
                const calculator = new StreakCalculator();
                
                const corruptedData = [
                    { date: '2025-07-21', achievedTarget: true, merges: 8000, dailyTarget: 7143 }, // Valid
                    { date: 'invalid-date', achievedTarget: true, merges: 5000 }, // Invalid date
                    { achievedTarget: false, merges: 6000 }, // Missing date
                    { date: '2025-07-22', achievedTarget: 'not-boolean', merges: '7000' }, // Wrong types
                    null, // Null item
                    { date: '2025-07-23', achievedTarget: true, merges: Infinity }, // Invalid number
                    { date: '2025-07-24', achievedTarget: false, merges: 5500, dailyTarget: 7143 } // Valid
                ];
                
                const sanitized = calculator.sanitizeDailyAchievementData(corruptedData);
                
                // Should keep only valid items with sanitized values
                runner.expect(sanitized).toHaveLength(3); // Only 3 valid/recoverable items
                
                sanitized.forEach(item => {
                    runner.expect(typeof item.date).toBe('string');
                    runner.expect(typeof item.achievedTarget).toBe('boolean');
                    runner.expect(typeof item.merges).toBe('number');
                    runner.expect(typeof item.dailyTarget).toBe('number');
                });
            });
            
            runner.test('should recover from various corruption scenarios', () => {
                const calculator = new StreakCalculator();
                
                // Test recovery from object with nested arrays
                const objectCorruption = {
                    dailyProgress: [
                        { date: '2025-07-21', achievedTarget: true, merges: 8000 },
                        { date: '2025-07-22', achievedTarget: false, merges: 5000 }
                    ],
                    otherData: 'ignore this'
                };
                
                const recovered1 = calculator.recoverFromCorruptedData(objectCorruption);
                runner.expect(recovered1).toHaveLength(2);
                
                // Test recovery with fallback data
                const totallyCorrupted = "completely invalid";
                const fallbackData = [
                    { date: '2025-07-20', achievedTarget: true, merges: 7000, dailyTarget: 7143 }
                ];
                
                const recovered2 = calculator.recoverFromCorruptedData(totallyCorrupted, fallbackData);
                runner.expect(recovered2).toHaveLength(1);
                runner.expect(recovered2[0].date).toBe('2025-07-20');
            });
            
            runner.test('should handle calculation errors gracefully', () => {
                const calculator = new StreakCalculator();
                
                // Override the calculateStreaks method to throw an error
                const originalCalculateStreaks = calculator.calculateStreaks;
                calculator.calculateStreaks = function() {
                    throw new Error('Simulated calculation error');
                };
                
                const result = calculator.safeCalculateStreaks([
                    { date: '2025-07-21', achievedTarget: true, merges: 8000, dailyTarget: 7143 }
                ]);
                
                // Should return safe defaults with error information
                runner.expect(result.currentStreak).toBe(0);
                runner.expect(result.longestStreak).toBe(0);
                runner.expect(result.error).toBe('Simulated calculation error');
                runner.expect(result.recovered).toBeFalsy();
                
                // Restore original method
                calculator.calculateStreaks = originalCalculateStreaks;
            });
            
            runner.test('should sanitize number values correctly', () => {
                const calculator = new StreakCalculator();
                
                runner.expect(calculator.sanitizeNumber(42)).toBe(42);
                runner.expect(calculator.sanitizeNumber(42.7)).toBe(43); // Rounded
                runner.expect(calculator.sanitizeNumber(-10, 5)).toBe(5); // Use default for negative
                runner.expect(calculator.sanitizeNumber(Infinity, 100)).toBe(100); // Use default for Infinity
                runner.expect(calculator.sanitizeNumber(NaN, 0)).toBe(0); // Use default for NaN
                runner.expect(calculator.sanitizeNumber('42', 10)).toBe(10); // Use default for string
                runner.expect(calculator.sanitizeNumber(null, 15)).toBe(15); // Use default for null
            });
            
            runner.test('should validate date strings correctly', () => {
                const calculator = new StreakCalculator();
                
                // Valid dates
                runner.expect(calculator.isValidDateString('2025-07-21')).toBeTruthy();
                runner.expect(calculator.isValidDateString('2025-01-01')).toBeTruthy();
                runner.expect(calculator.isValidDateString('2024-12-31')).toBeTruthy();
                
                // Invalid dates
                runner.expect(calculator.isValidDateString('invalid-date')).toBeFalsy();
                runner.expect(calculator.isValidDateString('2025-13-01')).toBeFalsy(); // Invalid month
                runner.expect(calculator.isValidDateString('2025-07-32')).toBeFalsy(); // Invalid day
                runner.expect(calculator.isValidDateString('25-07-21')).toBeFalsy(); // Wrong format
                runner.expect(calculator.isValidDateString('')).toBeFalsy();
                runner.expect(calculator.isValidDateString(null)).toBeFalsy();
                
                // Dates outside reasonable range
                runner.expect(calculator.isValidDateString('2010-07-21')).toBeFalsy(); // Too far in past
                runner.expect(calculator.isValidDateString('2035-07-21')).toBeFalsy(); // Too far in future
            });
            
            runner.test('should handle mixed valid and invalid data', () => {
                const calculator = new StreakCalculator();
                
                const mixedData = [
                    { date: '2025-07-20', achievedTarget: true, merges: 8000, dailyTarget: 7143 }, // Valid
                    { date: 'bad-date', achievedTarget: true, merges: 7000 }, // Invalid date
                    { date: '2025-07-21', achievedTarget: true, merges: 7500, dailyTarget: 7143 }, // Valid
                    { date: '2025-07-22', achievedTarget: true, merges: 8200, dailyTarget: 7143 }, // Valid
                    null, // Invalid entry
                    { date: '2025-07-23', achievedTarget: false, merges: 5000, dailyTarget: 7143 } // Valid
                ];
                
                const result = calculator.safeCalculateStreaks(mixedData);
                
                // Should successfully calculate with sanitized data
                runner.expect(result.currentStreak).toBe(0); // Ends with failed day
                runner.expect(result.longestStreak).toBe(3); // 3 consecutive valid achieved days
                runner.expect(result.totalDaysAchieved).toBe(3);
                runner.expect(result.streakHistory).toHaveLength(1);
            });
            
            runner.test('should maintain performance with error handling enabled', () => {
                const calculator = new StreakCalculator();
                
                // Generate dataset with some corruption
                const largeDatasetWithErrors = [];
                for (let i = 0; i < 1000; i++) {
                    if (i % 100 === 0) {
                        // Add corrupted entry every 100 items
                        largeDatasetWithErrors.push({ invalid: 'data' });
                    } else {
                        const date = new Date('2023-01-01');
                        date.setDate(date.getDate() + i);
                        largeDatasetWithErrors.push({
                            date: date.toISOString().split('T')[0],
                            achievedTarget: Math.random() > 0.3,
                            merges: Math.floor(Math.random() * 10000),
                            dailyTarget: 7143
                        });
                    }
                }
                
                const startTime = performance.now();
                const result = calculator.safeCalculateStreaks(largeDatasetWithErrors);
                const endTime = performance.now();
                
                const executionTime = endTime - startTime;
                console.log(`Safe calculation with errors: ${executionTime.toFixed(2)}ms`);
                
                // Should still perform reasonably well (under 100ms for 1000 items)
                runner.expect(executionTime).toBeLessThan(100);
                runner.expect(result.totalDaysAchieved).toBeGreaterThan(600); // Most items should be recovered
            });
        });

        // Run tests when page loads
        window.addEventListener('load', () => {
            console.log('Running Weekly Data Archiving Tests...');
        });
    </script>
</body>
</html>